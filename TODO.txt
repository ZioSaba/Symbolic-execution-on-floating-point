Dentro l'helper bisogna andare ad invocare funzioni del runtime di SymQEMU e poi dichiarare i metodi delle classi senza in:
https://github.com/ZioSaba/symcc/blob/master/runtime/qsym_backend/qsym/qsym/pintool/codegen/expr_builder.cpp



////////////////////////////////////////////
l'istruzione tcg_gen_addi_ptr serve per generare il codice che aa runtime calcolalerà l'indrizzo del registro xmm sorgente e destinazione dentro CPUX86State.
/////////////////////////////////////


Quali parametri dovrà prendere la mia sym_FloatingPointAdd:
- se la sorgente è un puntatore a memoria
  # bisogna andare a leggere nella memoria simbolica a quell'indirizzo nei rispettivi indirizzi (sym_read di 4 byte)
  # creare l'espressione della somma
  # scrivere l'espressione nella memoria simbolica del puntatore destinazione (sym_write di 4 byte)
  
  
  
Modificare la memoria simbolica facendo in modo che possa gestire correttamente i dati FP.
Vedi in RuntimeCommon.cpp per studiarti il backend simple e vedere le operazioni di lettura e scrittura in memoria.

 L'helper dovrà a grandi linee:

1) leggere l'espressione simbolica dalla memoria simbolica all'indirizzo a cui QEMU tiene registro sorgente XMM. sym_read_memory() ti restituirà una ConcatExpr di ExtractExpr su FloatingPointExpr (che devi definire tu).
Tu devi navigare le espressione e guardare solo FloatingPointExpr.

2)  leggere l'espressione simbolica dalla memoria simbolica all'indirizzo a cui QEMU tiene registro destinazione XMM. sym_read_memory() ti restituirà una ConcatExpr di ExtractExpr su FloatingPointExpr (che devi definire tu). 
Tu devi navigare le espressione e guardare solo FloatingPointExpr.


/****************************************************/
_sym_read_memory() attualmente ti darà sicuramente una espressione concat. Sarà qualcosa del tipo:

Concat(e1, e2)

dove:

e1 = Extract(...., o1)
e2 = Concat(e3, e4)
e3 = Extract(...., o1)
e4 = Concat(e5, e6)
....

Quindi tu dovrai "spacchettarla" per recuperare la tua espressione floating point, es. o1 nel mio esempio. Ti basta "navigare" l'espressione: per farlo potrebbe essere comodo definire un metodo nel runtime qsym che lo fa. 
Ricorda che solo il runtime QSYM può usare i metodi C++, mentre SymQEMU può solo invocare i metodi C _sym_qualcosa esportati dal runtime QSYM.

Dopo aver fatto la lettura di 4 byte nel puntatore ai registri, un "float" generalmente nasce da un operazione di conversione da intero. 
Quindi sono quei metodo che creano la tua espressione simbolica floating point e la mettono in memoria. 
Il tuo helper simbolica di addss deve solo "recuperare" dalla memoria quell'espressione, manipolarla (es. add), e riscriverla in memoria. 

Ci sono dei casi in cui un floating point non nasce attraverso un operazione di conversione da intero, ma per ora concretriamoci sul caso più semplice. 
Quindi per avere un primo prototipo devi modellare almeno un helper QEMU legato alla conversione da intero a float. Questo vuol dire gestirlo anche lato QSYM (dove nella gerarchia devi avere forse una classe IntToFloatConversion).
/*****************************************************/

3) costruire un espressione FloatingPointAddExpr usando come operandi quello che hai ottenuto a (1) e (2)

4) scriviere (3) in memoria simbolica con sym_write_memory all'indirizzo a cui QEMU tiene registro destinazione XMM. Internamente sym_write_memory() "spezzerà" in diverse ExtractExpr la tua FloatingPointAddExpr

/*****************************************************/
Qui devi solo fare in modo che sia possibile creare un Extract(...., e) su un espressione e costruita al punto (2). 
Se lo permetti, non devi fare altro. 
Se non lo permetti, allora dovrai modificare _sym_write_memory (che appunto fa un extract se l'oggetto è multi byte)
/*****************************************************/





Per recuperare i valori concreti dei due registri (dst e src), ti basta usare il puntatore che ricevi. env potrebbe non servirti in questo helper.
In generale può essere utile per accedere ad altri registri xmm (diversi dai due su cui hai già i puntatori) o qualsiasi altra cosa della vCPU. Ad esempio, ai fini di debug, puoi stamparti il valore attuale del program counter. 
Probabilmente per comiss ti servirà env.


Gli helper di conversioni devono essere dichiarati/definiti in modo diverso in quando prendo come input un temp (intero), lo convertono a float e lo scrivono nel registro xmm indicato dal puntatore. 
Quindi potrebbe venire definito come:

DEF_HELPER_4(sym_cvtsi2ss, void, env, ZMMReg, ptr, i32)

dove ZMMReg è il puntatore al registro xmm destinazione, ptr è conterrà il puntatore all'espressione simbolica del temp intero, mentre i32 il valore concreto del temp intero. Di nuovo env potrebbe far comodo per debug.


Visto che è una operazione unario, potresti semplificarlo a:

DEF_HELPER_3(sym_cvtsi2ss, void, env, ZMMReg, ptr)

Infatti se ptr è zero, non ti serve conoscere il valore concreto del temp, ma dovrai marcare la parte di memoria simbolica associata a ZMMReg come concreta.


L'helper sarà definito con qualcosa del tipo:

void helper_sym_cvtsi2ss(CPUX86State *env, ZMMReg *d, void* expr)
{
    // body
}

E dovrà:

1) se expr != NULL, allora deve creare espressione simbolica che modella conversione da int a float, e poi la scrive in memoria con sym_write_memory all'indirizzo d
2) se expr == NULL, deve scrivere a NULL con sym_write_memory 4 byte all'indirizzo d
Forse per correttezza non bisogna scrivere solo 4 byte ma tutti 16 byte (marcandoli sempre a NULL) ma bisogna vedere cosa dice Intel.

Ovviamente poi in translate.c devi passargli al gen_helper_.... i giusti argomenti. Se lo lasci come è ora ovviamente è sbagliato
Vedi come fa SymQEMU.



ALTRI HELPER:
- conversione da intero a FP
- comparazione
