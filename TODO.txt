Dentro l'helper bisogna andare ad invocare funzioni del runtime di SymQEMU e poi dichiarare i metodi delle classi senza in:
https://github.com/ZioSaba/symcc/blob/master/runtime/qsym_backend/qsym/qsym/pintool/codegen/expr_builder.cpp




Quali parametri dovrà prendere la mia sym_FloatingPointAdd:
- se la sorgente è un puntatore a memoria
  # bisogna andare a leggere nella memoria simbolica a quell'indirizzo nei rispettivi indirizzi (sym_read di 4 byte)
  # creare l'espressione della somma
  # scrivere l'espressione nella memoria simbolica del puntatore destinazione (sym_write di 4 byte)
  
  
  
Modificare la memoria simbolica facendo in modo che possa gestire correttamente i dati FP.
Vedi in RuntimeCommon.cpp per studiarti il backend simple e vedere le operazioni di lettura e scrittura in memoria.

Parti con implementare un helper che fa una printf() e vedi ti viene eseguito (dopo aver fatto le modifiche dette sopra). 
Se ti viene eseguito allora inizi a pensare a cosa deve fare questo helper. L'helper dovrà a grandi linee:

1) leggere l'espressione simbolica dalla memoria simbolica all'indirizzo a cui QEMU tiene registro sorgente XMM. sym_read_memory() ti restituirà una ConcatExpr di ExtractExpr su FloatingPointExpr (che devi definire tu).
Tu devi navigare le espressione e guardare solo FloatingPointExpr.

2)  leggere l'espressione simbolica dalla memoria simbolica all'indirizzo a cui QEMU tiene registro destinazione XMM. sym_read_memory() ti restituirà una ConcatExpr di ExtractExpr su FloatingPointExpr (che devi definire tu). 
Tu devi navigare le espressione e guardare solo FloatingPointExpr.


/****************************************************/
_sym_read_memory() attualmente ti darà sicuramente una espressione concat. Sarà qualcosa del tipo:

Concat(e1, e2)

dove:

e1 = Extract(...., o1)
e2 = Concat(e3, e4)
e3 = Extract(...., o1)
e4 = Concat(e5, e6)
....

Quindi tu dovrai "spacchettarla" per recuperare la tua espressione floating point, es. o1 nel mio esempio. Ti basta "navigare" l'espressione: per farlo potrebbe essere comodo definire un metodo nel runtime qsym che lo fa. 
Ricorda che solo il runtime QSYM può usare i metodi C++, mentre SymQEMU può solo invocare i metodi C _sym_qualcosa esportati dal runtime QSYM.

Dopo aver fatto la lettura di 4 byte nel puntatore ai registri, un "float" generalmente nasce da un operazione di conversione da intero. 
Quindi sono quei metodo che creano la tua espressione simbolica floating point e la mettono in memoria. 
Il tuo helper simbolica di addss deve solo "recuperare" dalla memoria quell'espressione, manipolarla (es. add), e riscriverla in memoria. 

Ci sono dei casi in cui un floating point non nasce attraverso un operazione di conversione da intero, ma per ora concretriamoci sul caso più semplice. 
Quindi per avere un primo prototipo devi modellare almeno un helper QEMU legato alla conversione da intero a float. Questo vuol dire gestirlo anche lato QSYM (dove nella gerarchia devi avere forse una classe IntToFloatConversion).
/*****************************************************/

3) costruire un espressione FloatingPointAddExpr usando come operandi quello che hai ottenuto a (1) e (2)

4) scriviere (3) in memoria simbolica con sym_write_memory all'indirizzo a cui QEMU tiene registro destinazione XMM. Internamente sym_write_memory() "spezzerà" in diverse ExtractExpr la tua FloatingPointAddExpr

/*****************************************************/
Qui devi solo fare in modo che sia possibile creare un Extract(...., e) su un espressione e costruita al punto (2). 
Se lo permetti, non devi fare altro. 
Se non lo permetti, allora dovrai modificare _sym_write_memory (che appunto fa un extract se l'oggetto è multi byte)
/*****************************************************/







ALTRI HELPER:
- conversione da intero a FP
- conversione da FP a intero
- comparazione
