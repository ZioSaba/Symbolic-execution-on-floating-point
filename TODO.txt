Secondo me puoi iniziare a giocare con Z3. Prova ad creare un programma che include header z3 e linka z3 e:
- esegue questo (che usa bitvector, ossia il tipo Z3 usato normalmente per rappresentare i dati interi)                     -> https://github.com/Z3Prover/z3/blob/master/examples/c/test_capi.c#L1441
- esegue questo (che non usa i bitvector ma il tipo "int" ma che mostra come chiamare Z3 eval per avere un assegnamento)    -> https://github.com/Z3Prover/z3/blob/master/examples/c/test_capi.c#L1473
- combina i due precenti esempi: modifica il secondo esempio per usare i bitvector

Fatto ciò, dovresti avere un idea di quello che attualmente fa un esecutore concolico:
- definisce dei bitvector non costanti da 8 bit per ogni byte dell'input. Ogni bitvector è per noi un simbolo.
- quando il programma esegue istruzioni, se almeno uno degli operandi è associato ad un bitvector non costante, allora riproduce l'operazione usando le api di Z3 sui rispettivi operandi, es. una  sub viene gestita usando Z3_mk_bvsub
- quando si arriva su un branch condizionale, si costruisce la formula legata alla condizione e si chiede al solver Z3 un assegnamento per la direzione true (condizione originale) o per la direzione false (!condizione)
- se il solver trova un assegnamento, allora si dumpa su file la soluzione per i singoli bitvector associati all'input del programma.

Se questi passaggi ti sono abbastanza chiari, il prossimo step è riprendere uno dei precedenti esempi Z3 e modificarli in modo da usare un tipo Z3 legato ai floating point invece che i bitvector. 
Fai diverse prove, provando a "riprodurre" diverse operazioni (add, sub, mul, etc., confronti di vario tipo). 

Fai un po' di prove e fammi sapere.

OT: ho scoperto che SymCC (che ha pezzi in comunque con SymQEMU) ha un supporto preliminare ai floating point. Come per KLEE, le scelte che hanno fatto loro ci possono guidare nello nostre scelte. -> https://github.com/eurecom-s3/symcc/blob/master/runtime/simple_backend/Runtime.cpp


Per x86, il manuale di riferimento è quello Intel. Guarda ad esempio sezione 4.9 del volume 1. Da quello che so le eccezioni sono gestite in vari modi:
(1) viene settato un registro, analogo a eflags ma per floating point, che può essere analizzato (simile a come fa una jcc per i condition code memorizzati nell'eflags) per capire eventuali errori. 
(2) alcune eccezioni generano interrupt che il kernel decide di gestire generando un segnale, es. se dividi per zero, il kernel manda al programma SIGFE.
Sempre nel volume 1 trovi tutto il capito 8 dedicato a x87. Il capitolo 9 copre MMX ed il 10 copre SSE. 

Nota: nel volume 2 trovi la descrizione delle istruzioni come hai visto fino ad ora sui siti disponibili online.

Non è roba semplice da capire ma se ci perdi un po' di tempo, dovresti poter aver un'idea più chiara. A noi non serve capire tutto ma almeno avere un'intuizione su come funziona. Io nono esperto della parte x87/SSE.