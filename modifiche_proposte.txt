La mia idea è creare due classi chiamate Integer_Operation e Floating_Point_Operation, che conterrebbero i seguenti metodi di conversione:

- Integer_Operation
    * unsigned int to signed int                        (possibile overflow)
    * signed int to unsigned int                        (possibile troncamento)
    * single precision floating point to int            (troncamento obbligatorio)
    * single precision floating point to unsigned int   (troncamento obbligatorio)
    * double precision floating point to int            (troncamento obbligatorio)
    * double precision floating point to unsigned int   (troncamento obbligatorio)

- Floating_Point
    * unsigned int to single precision floating point                       (possibile overflow e perdita di precisione)
    * unsigned int to double precision floating point                       (non dovrei gestire problemi) ???
    * signed int to single precision floating point                         (possibile overflow e perdita di precisione)
    * signed int to double precision floating point                         (non dovrei gestire problemi) ???
    * single precision floating point to double precision floating point    (non dovrei gestire problemi) ??? 
    * double precision floating point to single precision floating point    (perdita di precisione)




Dove definire le classi:

Dato che la add che si vuole implementare è un'operazione binaria, si potrebbe partire da Binary_Expr e definire le due sottoclassi.
Poiché poi le classi Linear e NonLinear di fatto non portano alcuna informazione utile, si potrebbero eliminare (?) e far estendere a tutte le operazioni intere direttamente Integer_Operation, e così analogamente per quelle in floating point.

Altrimenti, un'altra soluzione potrebbe essere modificare le classi Linear e NonLinear, aggiungendovi all'interno le due sottoclassi (ovviamente con nome diverso in modo che non ci sia overload tra quelle che estendo Linear e quelle che estendono NonLinear).
Questa soluzione modifica le classi nel punto più basso possibile, il che può essere comodo per avere una distinzione più netta anziché nel punto più alto della gerarchia.


Non credo che andare al di sopra di Binary_Expr possa essere una soluzione utile, dato che tale classe e tutte quelle soprastanti contengono metodi di uso generale, a meno che non potrebbe essere necessario riscrivere anche quelle operazioni per i FP.






PROF:


Riguardo le modifiche che hai proposto per la gerarchie delle classi di QSYM:
- servirebbe avere una struttura ad albero (una figura) delle classi attuali almeno per i primi K livelli della gerarchia altrimenti mi è difficile capire l'impatto delle tue modifiche
- non andrei ad eliminare classi esistenti per motivi di compatibilità
- i nomi delle classi che aggiunti devono usare la stessa convenzione sul formato dei nomi (non è Binary_Expr ma BinaryExpr)
- i nomi che proponi sono tra loro inconsistenti: IntegerOperation vs FloatingPoint (forse dovrebbe essere FloatingPointOperation?)
- QSYM mette se non sbaglio "Expr" nei nomi delle classi: forse quindi IntegerExpr e FloatingPointExpr?
- fai attenzione: non puoi considerare solo BinaryExpr nei tuoi ragionamenti! Come modelli una UnaryExpr e le altre classi? E' vero che tu non andrai a creare lato SYMQEMU tutte e possibili classi ma le devi prevdere! Altrimenti quello che fai andrà rifatto da zero quando lo si vuole estendere ad altre istruzioni diverse da add/cmp/etc che tu consideri. Forse quindi BinaryExpr (così come UnaryExpr) dovranno essere sottoclassi di IntegerOperation/FloatingPoint. Come detto però serve avere una visione d'insieme sulla gerarchia.


